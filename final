package main

import (
	"fmt"
	"os"
	"strconv"
	"strings"
)

// ------------ Créer une fonction pour lire un l'input -----------//
func ReadTheFile(input string) string {

	data, err := os.ReadFile(input)
	if err != nil {
		errFile := "ERROR: open " + string(input) + ": no such file or directory"
		fmt.Println(errFile)
		os.Exit(1)
	}
	return string(data)
}

// -----Créer et écrire dans un fichier-----//
func CreateAndWriteInAFile(output, finalContent string) {
	//création du fichier de sortie
	newFile, _ := os.Create(output)
	//écriture dans le nouveau fichier
	writeInFile, _ := newFile.WriteString(finalContent)

	fmt.Printf("last: %v\n", writeInFile)

}

//-----Vérifier qu'un élément est dans un tableau donnée-----//

func Contains(arr []string, ele string) bool {
	for _, v := range arr {
		if v == ele {
			return true
		}
	}
	return false
}

// -------Recherche l'index d'un élément----//
func Index(s []string, e string) int {
	for i, v := range s {
		if v == e {
			return i
		}

	}
	return -1
}

//-------Capitalise la premiére lettre et low le reste----//

func Capitalise(s string) string {

	so := []rune(s)
	count := 0
	for i := 0; i < len(s); i++ {
		if (so[i] >= 'a' && so[i] <= 'z') || (so[i] >= 'A' && so[i] <= 'Z') || (so[i] >= '0' && so[i] <= '9') {
			count++
		} else {
			count = 0
		}

		if count == 1 && so[i] >= 'a' && so[i] <= 'z' {
			so[i] -= 32

		} else if count > 1 && so[i] >= 'A' && so[i] <= 'Z' {
			so[i] += 32

		}
	}

	return string(so)
}

//--------Sort le nombre compris dans une chaine de caractére-----//

func Trimatoi(s string) int {
	signe := 1
	num := 0

	for i := 0; i < len(s); i++ {
		if s[i] >= '0' && s[i] <= '9' {
			num *= 10
			num += int(s[i] - 48)
		} else if s[i] == '-' && num == 0 {
			signe = -1
		}
	}
	return num * signe
}

// -------Vérifie le format du mot suivant-----//
func VerifyFormat(s []string, ele string) bool {
	number := Trimatoi(ele)
	//string du nombre
	numToString := strconv.Itoa(number)
	b := numToString + ")"
	return ele == b

}

// -------conversion base hexadecimal à la base de 10-----//
func ConvertBaseHexToTen(indicateur string) string {
	baseHexa, _ := strconv.ParseInt(indicateur, 16, 64)
	int64ToString := strconv.FormatInt(baseHexa, 10)
	return int64ToString
}

// --------conversion base binaire à la base de 10 ----------//
func ConvertBaseBinToTen(indicateur string) string {
	baseBin, _ := strconv.ParseInt(indicateur, 2, 64)
	int64ToString := strconv.FormatInt(baseBin, 10)
	return int64ToString
}

//-----fonction combinée----//

func Try(input, output string) {
	var finalArray, s []string

	all := []string{"(up)", "(cap)", "(low)", "(up,", "(cap,", "(low,", "(hex)", "(bin)"}
	once := []string{"(up,", "(cap,", "(low,"}

	filecontent := ReadTheFile(input)
	/////Enlever tout les espaces superflues/////
	s = strings.Fields(filecontent)
	for i := 0; i < len(s); i++ {
		if Contains(all, s[i]) && len(finalArray) == 0 {
			//par exemple si s[i] == (cap) mais que rien n'est stocké dans t alors qu'il ne fasse rien

		} else if Contains(once, s[i]) && i == len(s)-1 {
			//par exemple si on n'a (low, comme dernier élément
		} else if s[i] == "(hex)" && len(finalArray) != 0 {
			number := ConvertBaseHexToTen(finalArray[len(finalArray)-1])
			finalArray[len(finalArray)-1] = number

		} else if s[i] == "(bin)" && len(finalArray) != 0 {
			number := ConvertBaseBinToTen(finalArray[len(finalArray)-1])
			finalArray[len(finalArray)-1] = number

		} else if s[i] == "(cap)" && len(finalArray) != 0 {
			finalArray[len(finalArray)-1] = Capitalise(finalArray[len(finalArray)-1])
		} else if s[i] == "(up)" && len(finalArray) != 0 {
			finalArray[len(finalArray)-1] = strings.ToUpper(finalArray[len(finalArray)-1])
		} else if s[i] == "(low)" && len(finalArray) != 0 {
			finalArray[len(finalArray)-1] = strings.ToLower(finalArray[len(finalArray)-1])
		} else if Contains(once, s[i]) && !VerifyFormat(s, s[i+1]) {
			// par exemple si on a un (cap, mais que
			// le mot suivant ne respecte pas le format
		} else if s[i] == "(low," && VerifyFormat(s, s[i+1]) && len(finalArray) != 0 {
			number := Trimatoi(s[i+1])
			if number > 0 {
				if number < len(finalArray) {
					for i := len(finalArray) - 1; i >= len(finalArray)-number; i-- {
						finalArray[i] = strings.ToLower(finalArray[i])

					}
				} else if number >= len(finalArray) {
					for i := len(finalArray) - 1; i >= 0; i-- {
						finalArray[i] = strings.ToLower(finalArray[i])

					}
				}
			}
			// s[i+1] = ""
			s = append(s[:i+1], s[i+2:]...)

			continue

		} else if s[i] == "(cap," && VerifyFormat(s, s[i+1]) && len(finalArray) != 0 {
			number := Trimatoi(s[i+1])
			if number > 0 {
				if number < len(finalArray) {
					for i := len(finalArray) - 1; i >= len(finalArray)-number; i-- {
						finalArray[i] = Capitalise(finalArray[i])

					}
				} else if number >= len(finalArray) {
					for i := len(finalArray) - 1; i >= 0; i-- {
						finalArray[i] = Capitalise(finalArray[i])

					}
				}
			}
			// s[i+1] = ""
			s = append(s[:i+1], s[i+2:]...)

			continue

		} else if s[i] == "(up," && VerifyFormat(s, s[i+1]) && len(finalArray) != 0 {
			number := Trimatoi(s[i+1])
			if number > 0 {
				if number < len(finalArray) {
					for i := len(finalArray) - 1; i >= len(finalArray)-number; i-- {
						finalArray[i] = strings.ToUpper(finalArray[i])

					}

				} else if number >= len(finalArray) {
					for i := len(finalArray) - 1; i >= 0; i-- {
						finalArray[i] = strings.ToUpper(finalArray[i])

					}

				}
			}
			// s[i+1] = ""
			s = append(s[:i+1], s[i+2:]...)
			continue

		} else {
			finalArray = append(finalArray, s[i])
		}
	}
	finalContent := strings.Join(finalArray, " ")
	CreateAndWriteInAFile(output, finalContent)

}

func main() {

	arg := os.Args

	if len(arg) == 3 {
		Try(arg[1], arg[2])
	} else {
		fmt.Println("Peu, trop, ou pas d'élément")
		fmt.Println("Rééssayez!!!")
	}
}
